package it.cnr.istc.pst.platinum.ai.deliberative.solver;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.atomic.AtomicInteger;

import it.cnr.istc.pst.platinum.ai.framework.domain.component.DomainComponent;
import it.cnr.istc.pst.platinum.ai.framework.domain.component.DomainComponentType;
import it.cnr.istc.pst.platinum.ai.framework.microkernel.lang.flaw.Flaw;
import it.cnr.istc.pst.platinum.ai.framework.microkernel.lang.flaw.FlawType;
import it.cnr.istc.pst.platinum.ai.framework.microkernel.lang.plan.Plan;

/**
 * 
 * @author alessandro
 *
 */
public class SearchSpaceNode implements Comparable<SearchSpaceNode> {
	
	private static final AtomicInteger ID_COUNTER = new AtomicInteger(0);
	
	private int id;												// node unique ID
	private List<Operator> operators;							// node generation trace
	
	private Plan plan;											// associated (partial) plan
	
//	private Map<DomainComponent, List<DecisionVariable>> plan;	// partial plan
// 	private Map<DomainComponent, List<Flaw>> agenda; 			// flaws associated to the resulting partial plan
// 	
// 	// consolidated information about a partial plan 
// 	private Map<DomainComponent, Double[]> makespan;			// consolidated makespan of SVs
 	private Map<DomainComponent, Double> cost;					// consolidated planning cost of SVs
 	
 	// heuristic information about a partial plan 
 	private Map<DomainComponent, Double[]> heuristicMakespan;		// estimated makespan of SVs
 	private Map<DomainComponent, Double[]> heuristicCost;			// estimated planning cost of SVs
 	
	private Object domainSpecificMetric;						// node domain specific metric
	
	/**
	 * 
	 */
	protected SearchSpaceNode() 
	{
		// set node's id
		this.id = ID_COUNTER.getAndIncrement();
		// set operators
		this.operators = new ArrayList<>();
		
		// initialize (partial) plan
//		this.plan = new Plan();
		
		// set agenda
//		this.agenda = new HashMap<>();
		// set additional metric
		this.domainSpecificMetric = null;
//		this.makespan = new HashMap<>();
		this.cost = new HashMap<>();
		this.heuristicMakespan = new HashMap<>();
		this.heuristicCost = new HashMap<>();
	}
	
	/**
	 * Create a child node generated by means of the specified operator
	 * 
	 * @param parent
	 * @param op
	 */
	protected SearchSpaceNode(SearchSpaceNode parent, Operator op) 
	{
		this();
		// set operators
		this.operators = new ArrayList<>(parent.getOperators());
		// add generator
		this.operators.add(op);
		
		// set (partial) plan
		this.plan = parent.getPlan();
		
		// set agenda
//		this.agenda = new HashMap<>();
		
		// set additional metric
		this.domainSpecificMetric = null;
		
		// set cost
		this.cost = new HashMap<>(parent.getCost());
		// update cost according to the operator
		if (!this.cost.containsKey(op.getFlaw().getComponent())) {
			// set cost
			this.cost.put(op.getFlaw().getComponent(), op.getCost());
		}
		else {
			// update cost
			this.cost.put(op.getFlaw().getComponent(),
					this.cost.get(op.getFlaw().getComponent()) + op.getCost());
		}
		
		
		// set makespan 
//		this.makespan = new HashMap<>();
		this.heuristicCost = new HashMap<>();
		this.heuristicMakespan = new HashMap<>();
	}
	
	
	/**
	 * 
	 * @return
	 */
	public int getId() {
		return id;
	}
	
	/**
	 * 
	 * @return
	 */
	public Plan getPlan() {
		return new Plan(this.plan);
	}
	
	/**
	 * 
	 * @param metric
	 */
	public void setDomainSpecificMetric(Object metric) {
		this.domainSpecificMetric = metric;
	}
	
	/**
	 * 
	 * @return
	 */
	public Object getDomainSpecificMetric() {
		return domainSpecificMetric;
	}
	
	/**
	 * 
	 * @param flaw
	 */
	public void addFlaw(Flaw flaw) {
		// add the flaw to the underlying plan description
		this.plan.add(flaw.getComponent(), flaw);
//		if (!this.agenda.containsKey(flaw.getComponent())) {
//			this.agenda.put(flaw.getComponent(), new ArrayList<>());
//		}
//		
//		// add the flaw
//		this.agenda.get(flaw.getComponent()).add(flaw);
	}
	
	/**
	 * 
	 * @return
	 */
	public Set<Flaw> getFlaws() {
		// get flaws from the underlying plan description
		return new HashSet<>(this.plan.getFlaws());
		
//		Set<Flaw> list = new HashSet<>();
//		for (DomainComponent comp : this.agenda.keySet()) {
//			list.addAll(this.agenda.get(comp));
//		}
//		
//		return list;
	}
	
	/**
	 * 
	 * @return
	 */
	public Set<Flaw> getFlaws(FlawType type) {
		Set<Flaw> list = new HashSet<>();
//		for (DomainComponent comp : this.agenda.keySet()) {
		for (Flaw flaw : this.plan.getFlaws()) {
			// check flaw type
			if (flaw.getType().equals(type)) {
				// add the flaw
				list.add(flaw);
			}
		}
//		}
		
		return list;
	}
	
	/**
	 * 
	 * @return
	 */
	public int getNumberOfFlaws() {
//		int number = 0;
//		for (List<Flaw> list : this.agenda.values()) {
//			number += list.size();
//		}
		return this.getFlaws().size();
	}
	
	
	/**
	 * 
	 * @param comp
	 * @return
	 */
	public Set<Flaw> getFlaws(DomainComponent comp) {
		return new HashSet<>(this.plan.getFlaws(comp));
	}
	
	/**
	 * 
	 * @return
	 */
	public int getDepth() {
		return this.operators.size();
	}
		
	/**
	 * 
	 * @return
	 */
	public Map<DomainComponent, Double[]> getHeuristicCost() {
		return new HashMap<>(this.heuristicCost);
	}
	
	/**
	 * 
	 * @param hCost
	 */
	public void setHeuristicCost(Map<DomainComponent, Double[]> hCost) {
		this.heuristicCost = hCost;
	}
	
	/**
	 * 
	 * @return
	 */
	public Map<DomainComponent, Double[]> getHeuristicMakespan() {
		return new HashMap<>(this.heuristicMakespan);
	}
	
	/**
	 * 
	 * @param makespanHeuristic
	 */
	public void setHeuristicMakespan(Map<DomainComponent, Double[]> hMakespan) {
		this.heuristicMakespan = hMakespan;
	}
	
	/**
	 * 
	 * @param plan
	 */
	public void setPartialPlan(Plan plan) {
		this.plan = plan;
	}
	
	/**
	 * 
	 * @param partialPlan
	 */
//	public void setPartialPlan(Plan partialPlan) 
//	{
//		// set the partial plan 
//		this.plan = new HashMap<>();
//		// set of components 
//		Set<DomainComponent> cset = new HashSet<>();
//		
//		// check decisions
//		for (Decision dec : partialPlan.getDecisions()) 
//		{
//			// add component entry 
//			if (!this.plan.containsKey(dec.getComponent())) {
//				// add entry 
//				this.plan.put(dec.getComponent(), new ArrayList<>());
//			}
//			
//			// add decision variable
//			this.plan.get(dec.getComponent()).add(new DecisionVariable(dec));
//			
//			// check if primitive component
//			if (dec.getComponent().getType().equals(DomainComponentType.SV_PRIMITIVE)) {
//				// add component 
//				cset.add(dec.getComponent());
//			}
//		}
//		
//		
//		
//		// set makespan 
//		for (DomainComponent c : cset) 
//		{
//			// get component's decisions
//			if (this.plan.containsKey(c) && !this.plan.get(c).isEmpty()) 
//			{
//				// check last decision
//				DecisionVariable last = this.plan.get(c).get(0);
//				for (int index = 1; index < this.plan.get(c).size(); index++) {
//					// get current decision 
//					DecisionVariable d = this.plan.get(c).get(index);
//					
//					// check if last
//					if (d.getEnd()[0] > last.getEnd()[0]) {
//						// update last decision
//						last = d;
//					}
//				}
//				
//				
//				
//				// set component makespan according to end time bounds of the last decision
//				this.makespan.put(c, new Double[] {
//						(double) last.getEnd()[0],
//						(double) last.getEnd()[1]
//				});
//			}
//			else {
//				// no decision 
//				this.makespan.put(c, new Double[] {
//					(double) 0,
//					(double) 0
//				});
//			}
//		}
//	}
	
	/**
	 * 
	 * @return
	 */
//	public Map<DomainComponent, List<DecisionVariable>> getPartialPlan() {
//		// set the partial plan 
//		return new HashMap<>(this.plan);
//	}
	
	/**
	 * 
	 * @return
	 */
	public Map<DomainComponent, Double> getCost() {
		// get cost by components
		return new HashMap<>(this.cost);
	}
	
	/**
	 * 
	 * @return
	 */
	public double getPlanCost() {
		double cost = 0;
		for (DomainComponent c : this.cost.keySet()) {
			cost += this.cost.get(c);
		}
		
		return cost;
	}
	
	/**
	 * 
	 * @return
	 */
	public double[] getPlanHeuristicCost() {
		// set cost
		double[] cost = new double[] {
				0, 0
		};
		
		// set optimistic and pessimistic costs
		for (DomainComponent c : this.heuristicCost.keySet()) {
			cost[0] += this.heuristicCost.get(c)[0];
			cost[1] += this.heuristicCost.get(c)[1];
		}
		
		// get cost
		return cost;
	}
	
	/**
	 * Return the minimum and maximum makespan of the timelines of a plan
	 * 
	 * @return
	 */
	public double[] getPlanMakespan() {
		
		// set the makespan
		double[] mk = new double[] {
				Double.MIN_VALUE + 1,  
				Double.MAX_VALUE - 1
		};
		
		
		
		// set update flag
		boolean update = false;
		// compute makespan bounds
		for (DomainComponent c : this.plan.getMakespan().keySet()) {
			// check primitive components only
			if (c.getType().equals(DomainComponentType.SV_PRIMITIVE)) {
				// update min and max
				mk[0] = Math.max(mk[0], this.plan.getMakespan().get(c)[0]);
				// update max
				mk[1] = Math.min(mk[1], this.plan.getMakespan().get(c)[1]);
				// change update flag
				update = true;
			}
		}
		
		// check update flag
		if (!update) {
			// set default data 
			mk = new double[] {
					0, 
					Double.MAX_VALUE - 1
			};
		}
		
		// get plan makespan 
		return mk;
	}
	
	/**
	 * 
	 * @return
	 */
	public double[] getPlanHeuristicMakespan() {
		
		// set heuristic makespan
		double[] mk = new double[] {
				Double.MAX_VALUE - 1,
				Double.MIN_VALUE + 1 
		};
		
		// set update flag
		boolean update = false;
		// check heuristic makespan bounds of components 
		for (DomainComponent c : this.heuristicMakespan.keySet()) {
			// consider primitive components only 
			if (c.getType().equals(DomainComponentType.SV_PRIMITIVE)) {
				// update min and max
				mk[0] = Math.min(mk[0], this.heuristicMakespan.get(c)[0]);
				// update max
				mk[1] = Math.max(mk[1], this.heuristicMakespan.get(c)[1]);
				// change update flag
				update = true;
			}
		}
		
		// check update flag
		if (!update) {
			// set default data 
			mk = new double[] {
					0, 
					Double.MAX_VALUE - 1
			};
		}
		
		// get plan makespan 
		return mk;
	}
	
	/**
	 * Compute the estimated makespan as the sum of the consolidated and heuristic makespan
	 * 
	 * @param component
	 * @return
	 */
	public double[] getEstimatedMakespan(DomainComponent component) {
		
		// set heuristic makespan
		double[] mk = this.plan.getMakespan(component);
		
		// add heuristic value
		if (this.heuristicMakespan.containsKey(component)) {
			// increment
			mk[0] += this.heuristicMakespan.get(component)[0];
			mk[1] += this.heuristicMakespan.get(component)[1];
		}

		// get makespan
		return mk;
	}
	
	/**
	 * 
	 * @return
	 */
	public Map<DomainComponent, Double[]> getEstimatedMakespan() {
		
		// set data
		Map<DomainComponent, Double[]> mk = this.plan.getMakespan();
		// consider heuristic values
		for (DomainComponent comp : this.heuristicMakespan.keySet()) 
		{
			// add heuristic values
			double min = mk.containsKey(comp) ? mk.get(comp)[0] : 0;
			double max = mk.containsKey(comp) ? mk.get(comp)[1] : 0;
			
			// add heuristic value
			mk.put(comp, new Double[] {
				min + this.heuristicMakespan.get(comp)[0],
				max + this.heuristicMakespan.get(comp)[1]
			});
		}
		
		// get data
		return mk;
	}
	
	/**
	 * 
	 * @return
	 */
	public Map<DomainComponent, Double[]> getMakespan() {
		return new HashMap<>(this.plan.getMakespan());
	}
	
	/**
	 * Get the flaw that has been solved to generate the node 
	 * 
	 * @return
	 */
	public Flaw getGeneratingFlaw() {
		// verify whether the node is root
		return this.isRootNode() ? null : this.getGenerator().getFlaw();
	}
	
	/**
	 * Verify whether the node is root, i.e. not generator operator has been applied.
	 * 
	 * @return
	 */
	public boolean isRootNode() {
		// check if root node
		return this.getGenerator() == null;
	}
	
	/**
	 * The method returns the order list of operators that have been applied to generated the node. 
	 * 
	 * The last operator of the list is the node generator operator (i.e. the last applied operator).
	 * 
	 * @return
	 */
	public List<Operator> getOperators() {
		// get list of operators
		return new ArrayList<>(this.operators);
	}
	
	/**
	 * The method returns the node generator operator.
	 * 
	 * The method returns null for the root node of the search space
	 * 
	 * @return
	 */
	public Operator getGenerator() 
	{
		// get generator
		Operator operator = null;
		if (!this.operators.isEmpty()) {
			// get last applied operator
			operator = this.operators.get(this.operators.size() - 1);
		}
		
		// get generator operator
		return operator;
	}
	
	/**
	 * Get the list of applied operators from the more recent to the specified one (not included).
	 * 
	 * The method returns the list of operators that have been applied after the specified one starting with the more recent. The first
	 * element of the list is the node generator operator.
	 * 
	 * @param operator
	 * @return
	 */
	public List<Operator> getOperatorsUpTo(Operator operator) {
		// list of operators
		List<Operator> list = new ArrayList<>();
		if (operator == null) {
			// add all operators
			list.addAll(this.operators);
			// reverse order
			Collections.reverse(list);
		}
		else {
			// get index of the operator
			int index = this.operators.indexOf(operator);
			for (int i = this.operators.size() - 1; i > index; i--) {
				// add operator
				list.add(this.operators.get(i));
			}
		}
		// get list of operators
		return list;
	}
	
	/**
	 * Get the list of applied operators starting from the selected operator (not included).
	 * 
	 * The method returns the orderer list of operators that have been applied after the specified one. The 
	 * last operator of the list is the node generator operator.
	 * 
	 * 
	 * @param operator
	 * @return
	 */
	public List<Operator> getOperatorsFrom(Operator operator) {
		// list of operators
		List<Operator> list = new ArrayList<>();
		if (operator == null) {
			// add all operators
			list.addAll(this.operators);
		}
		else {
			// get index of the operator
			for (int index = this.operators.indexOf(operator) + 1; index < this.operators.size(); index++) {
				// add operator
				list.add(this.operators.get(index));
			}
		}
		// get list of operators
		return list;
	}
	
	/**
	 * 
	 */
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + id;
		return result;
	}

	/**
	 * 
	 */
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		SearchSpaceNode other = (SearchSpaceNode) obj;
		if (id != other.id)
			return false;
		return true;
	}
	
	/**
	 * 
	 */
	@Override
	public int compareTo(SearchSpaceNode o) {
		// compare nodes by their ID
		return this.id < o.id ? -1 : this.id > o.id ? 1 : 0;
	}
	
	/**
	 * 
	 */
	@Override
	public String toString() {
		// JSON style description of node
		return "{ "
				+ "\"id\": " + this.id + ", "
				+ "\"depth\": " + this.getDepth() + ", "
				+ "\"cost\": " + this.getPlanCost() + ", "
				+ "\"makespan\": [" + this.getPlanMakespan()[0] + ", " + this.getPlanMakespan()[1] + "], "
				+ "\"heuristic-cost\": [" + this.getPlanHeuristicCost()[0] +", " + this.getPlanHeuristicCost()[1] + "], "
				+ "\"heuristic-makespan\": [" + this.getPlanHeuristicMakespan()[0] + ", " + this.getPlanHeuristicMakespan()[1] + "] "
				+ " }";
	}
}
